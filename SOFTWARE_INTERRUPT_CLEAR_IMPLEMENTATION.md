# 软件中断清除实现总结

## 修改概述

本次修改将中断清除机制从激励阶段的自动清除改为由软件在收到中断后手动清除，以符合真实的应用场景。

## 主要修改内容

### 1. 中断路由序列修改 (`seq/int_routing_sequence.sv`)

#### 修改前的行为：
- 激励中断源 → 等待传播 → 自动释放信号 → 结束
- 中断在激励阶段就被自动清除，不符合实际应用

#### 修改后的行为：
- 激励中断源 → 等待中断检测 → 软件处理中断 → 软件清除中断 → 结束
- 模拟真实的中断处理流程

#### 具体修改：
1. **`check_single_interrupt_routing()`**: 
   - 移除自动的 `uvm_hdl_release()`
   - 添加 `wait_for_interrupt_detection()` 调用
   - 添加 `simulate_software_interrupt_clear()` 调用

2. **`test_merge_source_interrupt()`**:
   - 同样移除自动清除，改为软件清除

3. **`test_multiple_merge_sources()`**:
   - 对所有源中断都使用软件清除机制

4. **新增任务**:
   - `wait_for_interrupt_detection()`: 模拟中断检测延迟
   - `simulate_software_interrupt_clear()`: 调用软件处理程序

### 2. 软件中断处理程序 (`seq/int_software_handler.sv`)

#### 新增功能：
- **完整的ISR模拟**: 包含上下文保存、中断识别、处理、清除、恢复等步骤
- **真实的时序模拟**: 不同阶段有不同的时间延迟
- **统计功能**: 跟踪处理的中断数量和平均处理时间
- **可配置时序**: 可以调整各个阶段的时间参数

#### 主要任务：
1. **`handle_interrupt()`**: 主要的中断服务程序入口
2. **`simulate_context_save()`**: 模拟处理器上下文保存
3. **`simulate_interrupt_identification()`**: 模拟中断源识别
4. **`simulate_interrupt_handler_execution()`**: 模拟中断处理逻辑
5. **`simulate_interrupt_clear()`**: 模拟中断清除寄存器写入
6. **`simulate_context_restore()`**: 模拟处理器上下文恢复

#### 时序参数（默认值）：
- 上下文保存时间: 10ns
- 中断识别时间: 5ns  
- 处理程序执行时间: 30ns (根据中断类型可变)
- 清除寄存器写入时间: 2ns
- 上下文恢复时间: 8ns

### 3. 中断控制器模拟 (`rtl/int_controller.sv`)

#### 新增硬件模拟：
- **中断状态寄存器**: 锁存中断源的状态
- **中断清除寄存器**: 软件写入以清除中断
- **中断屏蔽寄存器**: 控制中断的使能/屏蔽
- **中断挂起寄存器**: 显示当前挂起的中断
- **APB接口**: 模拟处理器访问中断控制器的总线接口

#### 寄存器映射：
- `0x00`: 中断状态寄存器 (只读)
- `0x04`: 中断清除寄存器 (只写)
- `0x08`: 中断屏蔽寄存器 (读写)
- `0x0C`: 中断挂起寄存器 (只读)
- `0x10`: 中断配置寄存器 (读写)

## 实现优势

### 1. 真实性
- 模拟了真实系统中软件处理中断的完整流程
- 包含了实际的中断服务程序各个阶段
- 考虑了真实的时序延迟

### 2. 可观测性
- 提供详细的日志输出，显示中断处理的各个阶段
- 统计功能可以分析中断处理性能
- 清晰的时间戳显示中断处理时序

### 3. 可配置性
- 时序参数可以根据不同的处理器和系统配置调整
- 支持不同类型中断的差异化处理时间
- 可以模拟不同复杂度的中断处理程序

### 4. 可扩展性
- 软件处理程序可以轻松扩展以支持更复杂的中断处理逻辑
- 中断控制器可以扩展以支持更多的寄存器和功能
- 框架支持添加更多的中断类型和处理方式

## 使用示例

### 基本使用
```systemverilog
// 运行中断路由测试
int_routing_sequence seq = int_routing_sequence::type_id::create("seq");
seq.start(sequencer);

// 查看统计信息
int_software_handler::print_statistics();
```

### 配置时序参数
```systemverilog
// 配置更快的中断处理时序
int_software_handler::configure_timing(
    .ctx_save(5),      // 上下文保存: 5ns
    .int_id(2),        // 中断识别: 2ns  
    .handler(15),      // 处理程序: 15ns
    .clear_reg(1),     // 清除寄存器: 1ns
    .ctx_restore(4)    // 上下文恢复: 4ns
);
```

## 验证要点

### 1. 时序验证
- 验证中断从激励到清除的完整时序
- 确认软件处理各阶段的时间消耗符合预期
- 检查中断清除后信号确实被释放

### 2. 功能验证  
- 验证所有类型的中断都能被正确处理和清除
- 确认merge中断的源中断都能被正确清除
- 检查中断路由到各个目标的正确性

### 3. 性能验证
- 分析中断处理的平均时间
- 验证不同类型中断的处理时间差异
- 确认系统能够处理预期的中断负载

## 后续扩展建议

### 1. 中断优先级
- 添加中断优先级管理
- 实现中断嵌套处理
- 支持高优先级中断抢占

### 2. 多核支持
- 扩展为支持多个处理器核心
- 实现中断亲和性配置
- 支持核间中断通信

### 3. 高级功能
- 添加中断统计和性能监控
- 实现中断负载均衡
- 支持动态中断路由配置

## 结论

本次修改成功地将中断清除机制从简单的激励阶段自动清除改为了真实的软件清除模式。新的实现更加贴近实际硬件系统的行为，提供了更好的验证覆盖率和更真实的时序模拟。

修改后的系统不仅保持了原有的功能完整性，还增加了丰富的统计和监控功能，为后续的性能分析和系统优化提供了良好的基础。
