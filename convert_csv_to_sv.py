#!/usr/bin/env python3
import csv
import re
import argparse
from pathlib import Path

# --- Mappings ---
GROUP_MAP = {
    "IOSUB中断源": "IOSUB",
    "USB中断源": "USB",
    "SCP中断源": "SCP",
    "MCP中断源": "MCP",
    "SMMU中断源": "SMMU",
    "IODAP中断源": "IODAP",
    "外部中断源-from ACCEL": "ACCEL",
    "外部中断源-from CSUB": "CSUB",
    "外部中断源-from PSUB": "PSUB",
    "外部中断源-from PCIE1": "PCIE1",
    "外部中断源-from D2D": "D2D",
    "外部中断源-from DDR0": "DDR0",
    "外部中断源-from DDR1": "DDR1",
    "外部中断源-from ddr2": "DDR2",
    "外部中断源-from IO DIE": "IO_DIE"
}

TRIGGER_MAP = {
    "Level": "LEVEL",
    "Edge": "EDGE",
}

POLARITY_MAP = {
    "Active high": "ACTIVE_HIGH",
    "Active low": "ACTIVE_LOW", # Not in CSV, but good practice
    "Rising & Falling Edge": "RISING_FALLING",
}

def parse_interrupt_csv(input_path, output_path):
    """
    Parses the interrupt CSV file and generates a SystemVerilog routing model file.
    """
    sv_lines = [
        "`ifndef INT_ROUTING_MODEL_SV",
        "`define INT_ROUTING_MODEL_SV",
        "",
        "// This class serves as the prediction model for interrupt routing.",
        "// It is populated with data parsed from '中断向量表-iosub-V0.5.csv'.",
        "// NOTE: This file is auto-generated by the `convert_csv_to_sv.py` script.",
        "class int_routing_model;",
        "",
        "    // The main data structure holding all interrupt information.",
        "    static interrupt_info_s interrupt_map[];",
        "",
        "    // `build` function to populate the interrupt map.",
        "    static function void build();",
        "        interrupt_info_s entry;",
        "        interrupt_group_e current_group;",
        "",
        "        if (interrupt_map.size() > 0) return; // a simple guard to prevent multiple builds",
    ]

    try:
        with open(input_path, 'r', encoding='utf-8-sig') as csvfile:
            reader = csv.reader(csvfile)
            header = next(reader) # Skip header

            current_sv_group = ""

            for row in reader:
                if not any(field.strip() for field in row): continue

                # Check for group header row
                if not row[0].strip() and len(row) > 1 and "中断源" in row[1]:
                    csv_group_name = row[1].strip()
                    if csv_group_name in GROUP_MAP:
                        current_sv_group = GROUP_MAP[csv_group_name]
                        sv_lines.append(f"\n        // --- Start of {current_sv_group} interrupts ---")
                        sv_lines.append(f"        current_group = {current_sv_group};")
                    continue

                if not current_sv_group or not row[1].strip():
                    continue

                # Parse data rows
                index_str = row[1].strip()
                name = row[2].strip()
                trigger_str = row[5].strip()
                polarity_str = row[6].strip()
                to_ap = 1 if 'Y' in row[7].upper() or 'P' in row[7].upper() else 0
                to_scp = 1 if 'Y' in row[8].upper() or 'P' in row[8].upper() else 0
                to_mcp = 1 if 'Y' in row[9].upper() or 'P' in row[9].upper() else 0
                to_imu = 1 if 'Y' in row[10].upper() or 'P' in row[10].upper() else 0
                to_io = 1 if 'Y' in row[11].upper() or 'P' in row[11].upper() else 0
                to_other_die = 1 if 'Y' in row[12].upper() or 'P' in row[12].upper() else 0
                
                # Sanitize name
                name_sanitized = re.sub(r'(\s*\[\d+:\d+\]\s*)|(\s*\[\d+\]\s*)', '', name).strip()
                name_sanitized = name_sanitized.replace(' ', '_')
                
                # Map trigger and polarity
                trigger = TRIGGER_MAP.get(trigger_str, "UNKNOWN_TRIGGER")
                polarity = POLARITY_MAP.get(polarity_str, "UNKNOWN_POLARITY")
                
                # Construct the entry
                entry_str = (
                    f"        entry = '{{name:\"{name_sanitized}\", "
                    f"index:{index_str}, "
                    f"group:{current_sv_group}, "
                    f"trigger:{trigger}, "
                    f"polarity:{polarity}, "
                    f"rtl_path_src:\"\", "
                    f"to_ap:{to_ap}, rtl_path_ap:\"\", "
                    f"to_scp:{to_scp}, rtl_path_scp:\"\", "
                    f"to_mcp:{to_mcp}, rtl_path_mcp:\"\", "
                    f"to_imu:{to_imu}, rtl_path_imu:\"\", "
                    f"to_io:{to_io}, rtl_path_io:\"\", "
                    f"to_other_die:{to_other_die}, rtl_path_other_die:\"\""
                    "}; interrupt_map.push_back(entry);"
                )
                sv_lines.append(entry_str)

    except FileNotFoundError:
        print(f"Error: Input file not found at {input_path}")
        return
    except Exception as e:
        print(f"An error occurred: {e}")
        return

    sv_lines.extend([
        "    endfunction",
        "",
        "endclass",
        "",
        "`endif // INT_ROUTING_MODEL_SV"
    ])

    with open(output_path, 'w', encoding='utf-8') as svfile:
        svfile.write("\n".join(sv_lines))
    print(f"Successfully converted '{input_path}' to '{output_path}'")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Convert interrupt CSV to SystemVerilog routing model.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("csv_file", help="Path to the input CSV file (e.g., '中断向量表-iosub-V0.5.csv')")
    parser.add_argument(
        "-o", "--output", 
        default="seq/int_routing_model.sv",
        help="Path for the output SystemVerilog file.\n(default: 'seq/int_routing_model.sv')"
    )
    args = parser.parse_args()

    # Ensure output directory exists
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    parse_interrupt_csv(args.csv_file, output_path)
