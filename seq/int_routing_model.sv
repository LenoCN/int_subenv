`ifndef INT_ROUTING_MODEL_SV
`define INT_ROUTING_MODEL_SV

// This class serves as the prediction model for interrupt routing.
// It is populated with data parsed from int_vector.xlsx.
// NOTE: The build function content is auto-generated by the `convert_xlsx_to_sv.py` script.
class int_routing_model extends uvm_object;
    `uvm_object_utils(int_routing_model)

    // The main data structure holding all interrupt information.
    interrupt_info_s interrupt_map[$];

    // Constructor
    function new(string name = "int_routing_model");
        super.new(name);
    endfunction

    // `build` function to populate the interrupt map.
    function void build();
        interrupt_info_s entry;

        if (interrupt_map.size() > 0) return; // guard against multiple builds

        // Include auto-generated interrupt map entries from Excel file
`include "int_map_entries.svh"
    endfunction

    // Function to get all source interrupts that should be merged into a specific merge interrupt
    function int get_merge_sources(string merge_interrupt_name, ref interrupt_info_s sources[$]);
        sources.delete();

        case (merge_interrupt_name)
            "merge_pll_intr_lock": begin
                // Collect all PLL lock interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pll_lock_intr" ||
                        interrupt_map[i].name == "accel_pll_lock_intr" ||
                        interrupt_map[i].name == "psub_pll_lock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_lock_intr" ||
                        interrupt_map[i].name == "d2d_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_lock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL lock interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_lock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_unlock": begin
                // Collect all PLL unlock interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pll_unlock_intr" ||
                        interrupt_map[i].name == "accel_pll_unlock_intr" ||
                        interrupt_map[i].name == "psub_pll_unlock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_unlock_intr" ||
                        interrupt_map[i].name == "d2d_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_unlock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL unlock interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_unlock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechangedone": begin
                // Collect all PLL frechangedone interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechangedone_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL frechangedone interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_frechangedone") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechange_tot_done": begin
                // Collect all PLL frechange_tot_done interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechange_tot_done_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL frechange_tot_done interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_frechange_tot_done") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_intdocfrac_err": begin
                // Collect all PLL intdocfrac_err interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr1_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr2_pll_intdocfrac_err_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL intdocfrac_err interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_intdocfrac_err") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            // --- New merge interrupts based on CSV comment analysis ---

            "iosub_normal_intr": begin
                // Collect all interrupts that should be merged into iosub_normal_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pmbus0_intr" ||
                        interrupt_map[i].name == "iosub_pmbus1_intr" ||
                        interrupt_map[i].name == "iosub_mem_ist_intr" ||
                        interrupt_map[i].name == "iosub_dma_comreg_intr" ||
                        // All DMAC channel interrupts (ch0-ch15)
                        interrupt_map[i].name == "iosub_dma_ch0_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch1_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch2_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch3_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch4_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch5_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch6_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch7_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch8_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch9_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch10_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch11_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch12_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch13_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch14_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch15_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_slv_err_intr": begin
                // Collect all interrupts that should be merged into iosub_slv_err_intr
                // Note: iosub_slv_err_intr itself contains multiple sources as described in CSV
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "usb0_apb1ton_intr" ||
                        interrupt_map[i].name == "usb1_apb1ton_intr" ||
                        interrupt_map[i].name == "usb_top_apb1ton_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_cri_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_cri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_cri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_eri_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_eri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_eri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_fhi_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_fhi_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_fhi_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_0_intr": begin
                // Collect all interrupts that should be merged into iosub_abnormal_0_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iodap_etr_buf_intr" ||
                        interrupt_map[i].name == "iodap_catu_addrerr_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_1_intr": begin
                // iosub_abnormal_1_intr is a reserved merge signal with no sources
                // This is intentionally empty as it is reserved for future use
                // No sources to collect for this merge signal
            end

            "merge_external_pll_intr": begin
                // Collect all external PLL interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "accel_pll_lock_intr" ||
                        interrupt_map[i].name == "accel_pll_unlock_intr" ||
                        interrupt_map[i].name == "psub_pll_lock_intr" ||
                        interrupt_map[i].name == "psub_pll_unlock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_lock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_unlock_intr" ||
                        interrupt_map[i].name == "d2d_pll_lock_intr" ||
                        interrupt_map[i].name == "d2d_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_lock_intr" ||
                        // CSUB PLL interrupts (array format)
                        interrupt_map[i].name.substr(0, 15) == "csub_pll_intr_lock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            default: begin
                // Not a merge interrupt, return empty array
            end
        endcase

        return sources.size();
    endfunction

    // Function to check if an interrupt is a merge interrupt
    function bit is_merge_interrupt(string interrupt_name);
        return (interrupt_name == "merge_pll_intr_lock" ||
                interrupt_name == "merge_pll_intr_unlock" ||
                interrupt_name == "merge_pll_intr_frechangedone" ||
                interrupt_name == "merge_pll_intr_frechange_tot_done" ||
                interrupt_name == "merge_pll_intr_intdocfrac_err" ||
                // New merge interrupts from CSV analysis
                interrupt_name == "iosub_normal_intr" ||
                interrupt_name == "iosub_slv_err_intr" ||
                interrupt_name == "iosub_ras_cri_intr" ||
                interrupt_name == "iosub_ras_eri_intr" ||
                interrupt_name == "iosub_ras_fhi_intr" ||
                interrupt_name == "iosub_abnormal_0_intr" ||
                interrupt_name == "iosub_abnormal_1_intr" ||
                interrupt_name == "merge_external_pll_intr");
    endfunction

    // Helper function to check if an interrupt exists in the interrupt map
    function bit interrupt_exists(string interrupt_name);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                return 1;
            end
        end
        return 0;
    endfunction

    // Function to get merge interrupt info by name
    function interrupt_info_s get_merge_interrupt_info(string merge_interrupt_name);
        interrupt_info_s result;
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == merge_interrupt_name) begin
                return interrupt_map[i];
            end
        end
        // Return empty struct if not found
        result = '{default:0};
        return result;
    endfunction

    // Function to predict if an interrupt will be routed considering mask registers
    function bit predict_interrupt_routing_with_mask(string interrupt_name, string destination, int_register_model register_model);
        interrupt_info_s info;
        bit routing_enabled = 0;
        bit mask_enabled = 1;
        bit final_result;

        `uvm_info("INT_ROUTING_MODEL", $sformatf("🔮 Predicting routing for interrupt '%s' to destination '%s'", interrupt_name, destination), UVM_HIGH)

        // First check if interrupt exists and has routing to destination
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                info = interrupt_map[i];
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Found interrupt '%s' in routing model", interrupt_name), UVM_HIGH)
                break;
            end
        end

        // Check if routing is enabled for this destination
        case (destination.toupper())
            "AP": routing_enabled = info.to_ap;
            "SCP": routing_enabled = info.to_scp;
            "MCP": routing_enabled = info.to_mcp;
            "ACCEL": routing_enabled = info.to_accel;
            "IO": routing_enabled = info.to_io;
            "OTHER_DIE": routing_enabled = info.to_other_die;
            default: routing_enabled = 0;
        endcase

        `uvm_info("INT_ROUTING_MODEL", $sformatf("📊 Base routing check: interrupt '%s' to '%s' = %s",
                  interrupt_name, destination, routing_enabled ? "ENABLED" : "DISABLED"), UVM_HIGH)

        // Special handling for merge interrupts that may be further aggregated
        // Check if this interrupt is merged into another interrupt that has routing
        if (!routing_enabled && is_merge_interrupt(interrupt_name)) begin
            routing_enabled = check_indirect_routing_via_merge(interrupt_name, destination);
            `uvm_info("INT_ROUTING_MODEL", $sformatf("🔗 Indirect routing check via merge: interrupt '%s' to '%s' = %s",
                      interrupt_name, destination, routing_enabled ? "ENABLED" : "DISABLED"), UVM_HIGH)
        end

        // If routing is not enabled (neither direct nor indirect), interrupt will not be routed regardless of mask
        if (!routing_enabled) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("No routing (direct or indirect) for '%s' to '%s', final result: NO ROUTING",
                      interrupt_name, destination), UVM_HIGH)
            return 0;
        end

        // Check if interrupt is masked (returns 1 if masked, 0 if enabled)
        mask_enabled = !register_model.is_interrupt_masked(interrupt_name, destination, this);
        `uvm_info("INT_ROUTING_MODEL", $sformatf("🎭 Mask check: interrupt '%s' to '%s' = %s",
                  interrupt_name, destination, mask_enabled ? "ENABLED" : "MASKED"), UVM_HIGH)

        // Interrupt will be routed if both routing is enabled AND mask is enabled
        final_result = (routing_enabled && mask_enabled);
        `uvm_info("INT_ROUTING_MODEL", $sformatf("🎯 Final routing prediction: interrupt '%s' to '%s' = %s (routing=%b, mask=%b)",
                  interrupt_name, destination, final_result ? "WILL ROUTE" : "NO ROUTING", routing_enabled, mask_enabled), UVM_MEDIUM)
        return final_result;
    endfunction

    // Function to check if an interrupt has indirect routing via merge aggregation
    function bit check_indirect_routing_via_merge(string interrupt_name, string destination);
        bit has_indirect_routing = 0;

        `uvm_info("INT_ROUTING_MODEL", $sformatf("🔍 Checking indirect routing for '%s' to '%s' via merge aggregation", interrupt_name, destination), UVM_HIGH)

        // Check if this interrupt is a source for iosub_normal_intr
        if (is_iosub_normal_intr_source(interrupt_name)) begin
            // Check if iosub_normal_intr has routing to the destination
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == "iosub_normal_intr") begin
                    case (destination.toupper())
                        "SCP": has_indirect_routing = interrupt_map[i].to_scp;
                        "MCP": has_indirect_routing = interrupt_map[i].to_mcp;
                        "AP": has_indirect_routing = interrupt_map[i].to_ap;
                        "ACCEL": has_indirect_routing = interrupt_map[i].to_accel;
                        "IO": has_indirect_routing = interrupt_map[i].to_io;
                        "OTHER_DIE": has_indirect_routing = interrupt_map[i].to_other_die;
                        default: has_indirect_routing = 0;
                    endcase

                    if (has_indirect_routing) begin
                        `uvm_info("INT_ROUTING_MODEL", $sformatf("Found indirect routing: %s -> iosub_normal_intr -> %s",
                                  interrupt_name, destination), UVM_MEDIUM)
                    end
                    break;
                end
            end
        end

        // Add more merge aggregation cases here as needed
        // For example, other interrupts that are merged into higher-level merge signals

        return has_indirect_routing;
    endfunction

    // Function to check if an interrupt is a source for iosub_normal_intr merge
    // Based on IOSUB group and index ranges [0,9] and [15,50]
    function bit is_iosub_normal_intr_source(string interrupt_name);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                if (interrupt_map[i].group == IOSUB) begin
                    int idx = interrupt_map[i].index;
                    if ((idx >= 0 && idx <= 9) || (idx >= 15 && idx <= 50)) begin
                        `uvm_info("INT_ROUTING_MODEL", $sformatf("Identified as IOSUB normal interrupt source: %s (group=IOSUB, index=%0d)",
                                  interrupt_name, idx), UVM_HIGH)
                        return 1;
                    end else begin
                        `uvm_info("INT_ROUTING_MODEL", $sformatf("IOSUB interrupt but not normal range: %s (group=IOSUB, index=%0d)",
                                  interrupt_name, idx), UVM_HIGH)
                        return 0;
                    end
                end else begin
                    return 0; // Not IOSUB group
                end
            end
        end
        return 0; // Interrupt not found
    endfunction

    // Function to get all expected destinations for an interrupt considering masks
    function void get_expected_destinations_with_mask(string interrupt_name, ref string destinations[$], int_register_model register_model);
        string all_destinations[$] = {"AP", "SCP", "MCP", "ACCEL", "IO", "OTHER_DIE"};

        `uvm_info("INT_ROUTING_MODEL", $sformatf("🎯 Getting expected destinations with mask for interrupt: %s", interrupt_name), UVM_HIGH)

        destinations.delete();

        foreach (all_destinations[i]) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("🔍 Checking destination %0d/%0d: %s", i+1, all_destinations.size(), all_destinations[i]), UVM_HIGH)
            if (predict_interrupt_routing_with_mask(interrupt_name, all_destinations[i], register_model)) begin
                destinations.push_back(all_destinations[i]);
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Added destination: %s", all_destinations[i]), UVM_HIGH)
            end else begin
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Skipped destination: %s", all_destinations[i]), UVM_HIGH)
            end
        end

        `uvm_info("INT_ROUTING_MODEL", $sformatf("📋 Final expected destinations for '%s': %p (count: %0d)",
                  interrupt_name, destinations, destinations.size()), UVM_MEDIUM)
    endfunction

    // Function to check if any destination is expected for an interrupt
    function bit has_any_expected_destination_with_mask(string interrupt_name, int_register_model register_model);
        string destinations[$];
        get_expected_destinations_with_mask(interrupt_name, destinations, register_model);
        return (destinations.size() > 0);
    endfunction

    // Function to update status registers when interrupt occurs
    function void update_interrupt_status(string interrupt_name, bit status_value, int_register_model register_model);
        // Update the register model status
        register_model.update_status_register(interrupt_name, status_value);

        // Log the status update
        `uvm_info("INT_ROUTING_MODEL", $sformatf("Updated status for interrupt '%s' to %b",
                  interrupt_name, status_value), UVM_HIGH)
    endfunction

    // Function to print routing prediction with mask consideration
    function void print_routing_prediction_with_mask(string interrupt_name, int_register_model register_model);
        string destinations[$];
        interrupt_info_s info;
        string all_destinations[$];

        // Get interrupt info
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                info = interrupt_map[i];
                break;
            end
        end

        `uvm_info("INT_ROUTING_MODEL", $sformatf("=== Routing Prediction for '%s' ===", interrupt_name), UVM_MEDIUM)
        `uvm_info("INT_ROUTING_MODEL", $sformatf("Base routing: AP=%b, SCP=%b, MCP=%b, ACCEL=%b, IO=%b, OTHER_DIE=%b",
                  info.to_ap, info.to_scp, info.to_mcp, info.to_accel, info.to_io, info.to_other_die), UVM_MEDIUM)

        // Check each destination with mask consideration
        all_destinations[$] = {"AP", "SCP", "MCP", "ACCEL", "IO", "OTHER_DIE", "PSUB", "PCIE1", "CSUB"};
        foreach (all_destinations[i]) begin
            bit routing_enabled = predict_interrupt_routing_with_mask(interrupt_name, all_destinations[i], register_model);
            bit mask_status = !register_model.is_interrupt_masked(interrupt_name, all_destinations[i], this);
            bit base_routing;
            case (all_destinations[i])
                "AP": base_routing = info.to_ap;
                "SCP": base_routing = info.to_scp;
                "MCP": base_routing = info.to_mcp;
                "ACCEL": base_routing = info.to_accel;
                "IO": base_routing = info.to_io;
                "OTHER_DIE": base_routing = info.to_other_die;
                "PSUB": base_routing = (info.group == PSUB); // PSUB interrupts route to PSUB
                "PCIE1": base_routing = (info.group == PCIE1); // PCIE1 interrupts route to PCIE1
                "CSUB": base_routing = (info.group == CSUB); // CSUB interrupts route to CSUB
                default: base_routing = 0;
            endcase

            `uvm_info("INT_ROUTING_MODEL", $sformatf("  %s: routing=%b, mask_enabled=%b, final=%b",
                      all_destinations[i], base_routing, mask_status, routing_enabled), UVM_MEDIUM)
        end

        get_expected_destinations_with_mask(interrupt_name, destinations, register_model);
        if (destinations.size() > 0) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("Expected destinations: %p", destinations), UVM_MEDIUM)
        end else begin
            `uvm_info("INT_ROUTING_MODEL", "No expected destinations (all masked or no routing)", UVM_MEDIUM)
        end
        `uvm_info("INT_ROUTING_MODEL", "=== End Routing Prediction ===", UVM_MEDIUM)
    endfunction

endclass

`endif // INT_ROUTING_MODEL_SV
