`ifndef INT_ROUTING_MODEL_SV
`define INT_ROUTING_MODEL_SV

// This class serves as the prediction model for interrupt routing.
// It is populated with data parsed from 'int_vector.xlsx'.
// NOTE: The build function content is auto-generated by the `convert_xlsx_to_sv.py` script.
class int_routing_model extends uvm_object;
    `uvm_object_utils(int_routing_model)

    // The main data structure holding all interrupt information.
    interrupt_info_s interrupt_map[$];

    // Constructor
    function new(string name = "int_routing_model");
        super.new(name);
    endfunction

    // `build` function to populate the interrupt map.
    function void build();
        interrupt_info_s entry;

        if (interrupt_map.size() > 0) return; // guard against multiple builds

        // Include auto-generated interrupt map entries from Excel file
`include "int_map_entries.svh"
    endfunction

    // Function to get all source interrupts that should be merged into a specific merge interrupt
    function int get_merge_sources(string merge_interrupt_name, ref interrupt_info_s sources[$]);
        int n;
        sources.delete();
        
        // pmerge_normalN_intr: N in [0..8]
        if ($sscanf(merge_interrupt_name, "pmerge_normal%0d_intr", n) == 1) begin
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == $sformatf("psub_normal%0d_intr",  n) ||
                    interrupt_map[i].name == $sformatf("pcie1_normal%0d_intr", n)) begin
                    sources.push_back(interrupt_map[i]);
                end
            end
            return sources.size();
        end
        
        // pmerge_abnormalN_intr: N in [0..7]
        if ($sscanf(merge_interrupt_name, "pmerge_abnormal%0d_intr", n) == 1) begin
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == $sformatf("psub_abnormal%0d_intr",  n) ||
                    interrupt_map[i].name == $sformatf("pcie1_abnormal%0d_intr", n)) begin
                    sources.push_back(interrupt_map[i]);
                end
            end
            return sources.size();
        end
        
        // pmerge_ras_{cri,eri,fhi}_intr
        if (merge_interrupt_name == "pmerge_ras_cri_intr") begin
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == "psub_ras_cri_intr" ||
                    interrupt_map[i].name == "pcie1_ras_cri_intr") begin
                    sources.push_back(interrupt_map[i]);
                end
            end
            return sources.size();
        end
        if (merge_interrupt_name == "pmerge_ras_eri_intr") begin
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == "psub_ras_eri_intr" ||
                    interrupt_map[i].name == "pcie1_ras_eri_intr") begin
                    sources.push_back(interrupt_map[i]);
                end
            end
            return sources.size();
        end
        if (merge_interrupt_name == "pmerge_ras_fhi_intr") begin
            foreach (interrupt_map[i]) begin
                if (interrupt_map[i].name == "psub_ras_fhi_intr" ||
                    interrupt_map[i].name == "pcie1_ras_fhi_intr") begin
                    sources.push_back(interrupt_map[i]);
                end
            end
            return sources.size();
        end

        case (merge_interrupt_name)
            "merge_pll_intr_lock": begin
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name.match("csub_pll_intr_lock_*") ||
                        interrupt_map[i].name == "iosub_pll_lock_intr" ||
                        interrupt_map[i].name == "accel_pll_lock_intr" ||
                        interrupt_map[i].name == "psub_pll_lock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_lock_intr" ||
                        interrupt_map[i].name == "d2d_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_lock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_unlock": begin
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name.match("csub_pll_intr_unlock_*") ||
                        interrupt_map[i].name == "iosub_pll_unlock_intr" ||
                        interrupt_map[i].name == "accel_pll_unlock_intr" ||
                        interrupt_map[i].name == "psub_pll_unlock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_unlock_intr" ||
                        interrupt_map[i].name == "d2d_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_unlock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechangedone": begin
                 foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name.match("csub_pll_intr_frechangedone_*") || // MODIFIED: Match pattern
                        interrupt_map[i].name == "ddr0_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechangedone_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechange_tot_done": begin
                 foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name.match("csub_pll_intr_frechange_tot_done_*") || // MODIFIED: Match pattern
                        interrupt_map[i].name == "ddr0_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechange_tot_done_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_intdocfrac_err": begin
                 foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name.match("csub_pll_intr_intdocfrac_err_*") || // MODIFIED: Match pattern
                        interrupt_map[i].name == "ddr0_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr1_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr2_pll_intdocfrac_err_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_normal_intr": begin
                // Collect all interrupts that should be merged into iosub_normal_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].group == IOSUB) begin
                        int idx = interrupt_map[i].index;
                        if ((idx >= 0 && idx <= 9) || (idx >= 15 && idx <= 50)) begin
                            sources.push_back(interrupt_map[i]);
                        end
                    end
                end
            end

            "iosub_slv_err_intr": begin
                // Collect all interrupts that should be merged into iosub_slv_err_intr
                // Note: iosub_slv_err_intr itself contains multiple sources as described in CSV
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_nic400_in_slverr_wr_intr"   ||
                        interrupt_map[i].name == "iosub_nic400_in_slverr_rd_intr"   ||
                        interrupt_map[i].name == "iosub_nic400_out_slverr_wr_intr"  ||
                        interrupt_map[i].name == "iosub_nic400_out_slverr_rd_intr"  ||
                        interrupt_map[i].name == "iosub_apb1ton_pslverr_intr"       ||
                        interrupt_map[i].name == "usb0_apb1ton_intr" ||
                        interrupt_map[i].name == "usb1_apb1ton_intr" ||
                        interrupt_map[i].name == "usb_top_apb1ton_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_cri_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_cri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_cri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_eri_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_eri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_eri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_fhi_intr": begin
                // Collect only SMMU interrupts that should be merged into iosub_ras_fhi_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_fhi_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_0_intr": begin
                // Collect all interrupts that should be merged into iosub_abnormal_0_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iodap_etr_buf_intr" ||
                        interrupt_map[i].name == "iodap_catu_addrerr_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_1_intr": begin
                // iosub_abnormal_1_intr is a reserved merge signal with no sources
                // This is intentionally empty as it's reserved for future use
                // No sources to collect for this merge signal
            end

            default: begin
                // Not a merge interrupt, return empty array
            end
        endcase

        return sources.size();
    endfunction

    // Function to check if an interrupt is a merge interrupt
    function bit is_merge_interrupt(string interrupt_name);
        return (interrupt_name == "merge_pll_intr_lock" ||
                interrupt_name == "merge_pll_intr_unlock" ||
                interrupt_name == "merge_pll_intr_frechangedone" ||
                interrupt_name == "merge_pll_intr_frechange_tot_done" ||
                interrupt_name == "merge_pll_intr_intdocfrac_err" ||
                interrupt_name == "iosub_normal_intr" ||
                interrupt_name == "iosub_slv_err_intr" ||
                interrupt_name == "iosub_ras_cri_intr" ||
                interrupt_name == "iosub_ras_eri_intr" ||
                interrupt_name == "iosub_ras_fhi_intr" ||
                interrupt_name == "iosub_abnormal_0_intr" ||
                interrupt_name == "iosub_abnormal_1_intr" ||
                interrupt_name.substr(0,7) == "pmerge_");
    endfunction

    // Helper function to check if an interrupt exists in the interrupt map
    function bit interrupt_exists(string interrupt_name);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                return 1;
            end
        end
        return 0;
    endfunction

    // Function to predict if an interrupt will be routed considering mask registers
    function bit predict_interrupt_routing_with_mask(string interrupt_name, string destination, int_register_model register_model);
        interrupt_info_s info;
        bit routing_enabled = 0;
        bit mask_enabled = 1;
        bit final_result;

        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Predicting routing for interrupt '%s' to destination '%s'", interrupt_name, destination), UVM_HIGH)

        // First check if interrupt exists and has routing to destination
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                info = interrupt_map[i];
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Found interrupt '%s' in routing model", interrupt_name), UVM_HIGH)
                break;
            end
        end

        // Check if routing is enabled for this destination
        case (destination.toupper())
            "AP": routing_enabled = info.to_ap;
            "SCP": routing_enabled = info.to_scp;
            "MCP": routing_enabled = info.to_mcp;
            "ACCEL": routing_enabled = info.to_accel;
            "IO": routing_enabled = info.to_io;
            "OTHER_DIE": routing_enabled = info.to_other_die;
            default: routing_enabled = 0;
        endcase

        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Base routing check: interrupt '%s' to '%s' = %s",
                  interrupt_name, destination, routing_enabled ? "ENABLED" : "DISABLED"), UVM_HIGH)

        // Special handling for merge interrupts that may be further aggregated
        // Check if this interrupt is merged into another interrupt that has routing
        if (!routing_enabled && is_merge_interrupt(interrupt_name)) begin
            routing_enabled = check_indirect_routing_via_merge(interrupt_name, destination);
            `uvm_info("INT_ROUTING_MODEL", $sformatf(" Indirect routing check via merge: interrupt '%s' to '%s' = %s",
                      interrupt_name, destination, routing_enabled ? "ENABLED" : "DISABLED"), UVM_HIGH)
        end

        // If routing is not enabled (neither direct nor indirect), interrupt will not be routed regardless of mask
        if (!routing_enabled) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("No routing (direct or indirect) for '%s' to '%s', final result: NO ROUTING",
                      interrupt_name, destination), UVM_HIGH)
            return 0;
        end

        // Check if interrupt is masked (returns 1 if masked, 0 if enabled)
        mask_enabled = !register_model.is_interrupt_masked(interrupt_name, destination, this);
        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Mask check: interrupt '%s' to '%s' = %s",
                  interrupt_name, destination, mask_enabled ? "ENABLED" : "MASKED"), UVM_HIGH)

        // Interrupt will be routed if both routing is enabled AND mask is enabled
        final_result = (routing_enabled && mask_enabled);
        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Final routing prediction: interrupt '%s' to '%s' = %s (routing=%b, mask=%b)",
                  interrupt_name, destination, final_result ? "WILL ROUTE" : "NO ROUTING", routing_enabled, mask_enabled), UVM_MEDIUM)
        return final_result;
    endfunction

    // 添加辅助函数：检查是否是 intermediate merge（自身有 higher merges）
    function bit is_intermediate_merge(string interrupt_name);
        string temp[$];
        get_merge_interrupts_for_source(interrupt_name, temp);
        return (temp.size() > 0);
    endfunction

    // Function to check if an interrupt has indirect routing via merge aggregation
    function bit check_indirect_routing_via_merge(string interrupt_name, string destination);
        bit has_indirect_routing = 0;
        string merges[$];
        interrupt_info_s merge_info;

        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Checking indirect routing for '%s' to '%s' via merge aggregation", interrupt_name, destination), UVM_HIGH)

        // 新增：如果这是 intermediate merge，跳过 indirect prediction（预期应为 higher merge）
        if (is_intermediate_merge(interrupt_name)) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("⚠️  Skipping indirect routing for intermediate merge '%s'", interrupt_name), UVM_HIGH)
            return 0;
        end

        // Find all merges this source contributes to
        get_merge_interrupts_for_source(interrupt_name, merges);

        // Check if this interrupt is a source for merge interrupt 
        foreach (merges[i]) begin
            if (get_merge_interrupt_info(merges[i], merge_info)) begin
                case (destination.toupper())
                    "AP":        has_indirect_routing |= merge_info.to_ap;
                    "SCP":       has_indirect_routing |= merge_info.to_scp;
                    "MCP":       has_indirect_routing |= merge_info.to_mcp;
                    "ACCEL":     has_indirect_routing |= merge_info.to_accel;
                    "IO":        has_indirect_routing |= merge_info.to_io;
                    "OTHER_DIE": has_indirect_routing |= merge_info.to_other_die;
                    default:     has_indirect_routing |= 0;
                endcase
                if (has_indirect_routing) begin
                    `uvm_info("INT_ROUTING_MODEL", $sformatf("Found indirect routing: %s -> iosub_normal_intr -> %s",
                              interrupt_name, destination), UVM_MEDIUM)
                end
            end
        end

        return has_indirect_routing;
    endfunction

    // Function to check if an interrupt is a source for iosub_normal_intr merge
    // Based on IOSUB group and index ranges [0,9] and [15,50]
    function bit is_iosub_normal_intr_source(string interrupt_name);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                if (interrupt_map[i].group == IOSUB) begin
                    int idx = interrupt_map[i].index;
                    if ((idx >= 0 && idx <= 9) || (idx >= 15 && idx <= 50)) begin
                        `uvm_info("INT_ROUTING_MODEL", $sformatf("Identified as IOSUB normal interrupt source: %s (group=IOSUB, index=%0d)",
                                  interrupt_name, idx), UVM_HIGH)
                        return 1;
                    end else begin
                        `uvm_info("INT_ROUTING_MODEL", $sformatf("IOSUB interrupt but not normal range: %s (group=IOSUB, index=%0d)",
                                  interrupt_name, idx), UVM_HIGH)
                        return 0;
                    end
                end else begin
                    return 0; // Not IOSUB group
                end
            end
        end
        return 0; // Interrupt not found
    endfunction

    // Function to get all expected destinations for an interrupt considering masks
    function void get_expected_destinations_with_mask(string interrupt_name, ref string destinations[$], int_register_model register_model);
        string all_destinations[$] = {"AP", "SCP", "MCP", "ACCEL", "IO", "OTHER_DIE"};

        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Getting expected destinations with mask for interrupt: %s", interrupt_name), UVM_HIGH)

        destinations.delete();

        foreach (all_destinations[i]) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf(" Checking destination %0d/%0d: %s", i+1, all_destinations.size(), all_destinations[i]), UVM_HIGH)
            if (predict_interrupt_routing_with_mask(interrupt_name, all_destinations[i], register_model)) begin
                destinations.push_back(all_destinations[i]);
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Added destination: %s", all_destinations[i]), UVM_HIGH)
            end else begin
                `uvm_info("INT_ROUTING_MODEL", $sformatf("Skipped destination: %s", all_destinations[i]), UVM_HIGH)
            end
        end

        `uvm_info("INT_ROUTING_MODEL", $sformatf(" Final expected destinations for '%s': %p (count: %0d)",
                  interrupt_name, destinations, destinations.size()), UVM_MEDIUM)
    endfunction

    // Function to check if any destination is expected for an interrupt
    function bit has_any_expected_destination_with_mask(string interrupt_name, int_register_model register_model);
        string destinations[$];
        get_expected_destinations_with_mask(interrupt_name, destinations, register_model);
        return (destinations.size() > 0);
    endfunction

    // Function to update status registers when interrupt occurs
    function void update_interrupt_status(string interrupt_name, bit status_value, int_register_model register_model);
        // Update the register model status
        register_model.update_status_register(interrupt_name, status_value);

        // Log the status update
        `uvm_info("INT_ROUTING_MODEL", $sformatf("Updated status for interrupt '%s' to %b",
                  interrupt_name, status_value), UVM_HIGH)
    endfunction

    // High-level function to get merge interrupt info by name
    function bit get_merge_interrupt_info(string merge_name, ref interrupt_info_s merge_info);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == merge_name) begin
                merge_info = interrupt_map[i];
                `uvm_info("INT_ROUTING_MODEL", $sformatf("✅ Found merge interrupt info for '%s'", merge_name), UVM_HIGH)
                return 1;
            end
        end
        `uvm_info("INT_ROUTING_MODEL", $sformatf("❌ Merge interrupt '%s' not found", merge_name), UVM_MEDIUM)
        return 0;
    endfunction

    // High-level function to get all merge interrupts that a source interrupt contributes to
    function void get_merge_interrupts_for_source(string source_name, ref string merge_interrupts[$]);
        bit exists;
        `uvm_info(get_type_name(), $sformatf("Dynamically finding merge interrupts for source: %s", source_name), UVM_HIGH)
        merge_interrupts.delete();

        // Iterate through all potential merge interrupts in the map by checking their 'is_merge_interrupt' property
        foreach (interrupt_map[i]) begin
            // We only care about entries that are themselves merge targets
            if (is_merge_interrupt(interrupt_map[i].name)) begin
                interrupt_info_s possible_sources[$];
                
                // Get the list of sources for this potential merge interrupt
                get_merge_sources(interrupt_map[i].name, possible_sources);

                // Check if our 'source_name' is in the list of sources
                foreach (possible_sources[j]) begin
                    if (possible_sources[j].name == source_name) begin
                        // It is a source! Add the merge interrupt name to our results.
                        
                        // Check for duplicates before adding, just in case.
                        exists = 0;
                        foreach(merge_interrupts[k]) begin
                          if(merge_interrupts[k] == interrupt_map[i].name) exists = 1;
                        end

                        if (!exists) begin
                            merge_interrupts.push_back(interrupt_map[i].name);
                            `uvm_info(get_type_name(), $sformatf("  => Found: '%s' is a source for merge interrupt '%s'", source_name, interrupt_map[i].name), UVM_HIGH);
                        end
                        break; // Found it, no need to check other sources for this merge interrupt. Move to the next.
                    end
                end
            end
        end

        if (merge_interrupts.size() == 0) begin
            `uvm_info(get_type_name(), $sformatf("  => No merge interrupts found for source: %s", source_name), UVM_HIGH)
        end
    endfunction


endclass

`endif // INT_ROUTING_MODEL_SV
