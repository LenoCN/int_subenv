`ifndef INT_ROUTING_MODEL_SV
`define INT_ROUTING_MODEL_SV

// This class serves as the prediction model for interrupt routing.
// It is populated with data parsed from 'int_vector.xlsx'.
// NOTE: The build function content is auto-generated by the `convert_xlsx_to_sv.py` script.
class int_routing_model;

    // The main data structure holding all interrupt information.
    static interrupt_info_s interrupt_map[$];

    // `build` function to populate the interrupt map.
    static function void build();
        interrupt_info_s entry;

        if (interrupt_map.size() > 0) return; // guard against multiple builds

        // Include auto-generated interrupt map entries from Excel file
`include "int_map_entries.svh"
    endfunction

    // Function to get all source interrupts that should be merged into a specific merge interrupt
    static function int get_merge_sources(string merge_interrupt_name, ref interrupt_info_s sources[$]);
        sources.delete();

        case (merge_interrupt_name)
            "merge_pll_intr_lock": begin
                // Collect all PLL lock interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pll_lock_intr" ||
                        interrupt_map[i].name == "accel_pll_lock_intr" ||
                        interrupt_map[i].name == "psub_pll_lock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_lock_intr" ||
                        interrupt_map[i].name == "d2d_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_lock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL lock interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_lock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_unlock": begin
                // Collect all PLL unlock interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pll_unlock_intr" ||
                        interrupt_map[i].name == "accel_pll_unlock_intr" ||
                        interrupt_map[i].name == "psub_pll_unlock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_unlock_intr" ||
                        interrupt_map[i].name == "d2d_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_unlock_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL unlock interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_unlock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechangedone": begin
                // Collect all PLL frechangedone interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechangedone_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechangedone_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL frechangedone interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_frechangedone") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_frechange_tot_done": begin
                // Collect all PLL frechange_tot_done interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr1_pll_frechange_tot_done_intr" ||
                        interrupt_map[i].name == "ddr2_pll_frechange_tot_done_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL frechange_tot_done interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_frechange_tot_done") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "merge_pll_intr_intdocfrac_err": begin
                // Collect all PLL intdocfrac_err interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "ddr0_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr1_pll_intdocfrac_err_intr" ||
                        interrupt_map[i].name == "ddr2_pll_intdocfrac_err_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
                // Add CSUB PLL intdocfrac_err interrupts
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "csub_pll_intr_intdocfrac_err") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            // --- New merge interrupts based on CSV comment analysis ---

            "iosub_normal_intr": begin
                // Collect all interrupts that should be merged into iosub_normal_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iosub_pmbus0_intr" ||
                        interrupt_map[i].name == "iosub_pmbus1_intr" ||
                        interrupt_map[i].name == "iosub_mem_ist_intr" ||
                        interrupt_map[i].name == "iosub_dma_comreg_intr" ||
                        // All DMAC channel interrupts (ch0-ch15)
                        interrupt_map[i].name == "iosub_dma_ch0_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch1_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch2_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch3_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch4_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch5_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch6_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch7_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch8_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch9_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch10_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch11_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch12_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch13_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch14_intr" ||
                        interrupt_map[i].name == "iosub_dma_ch15_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_slv_err_intr": begin
                // Collect all interrupts that should be merged into iosub_slv_err_intr
                // Note: iosub_slv_err_intr itself contains multiple sources as described in CSV
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "usb0_apb1ton_intr" ||
                        interrupt_map[i].name == "usb1_apb1ton_intr" ||
                        interrupt_map[i].name == "usb_top_apb1ton_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_cri_intr": begin
                // Collect all interrupts that should be merged into iosub_ras_cri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_cri_intr" ||
                        interrupt_map[i].name == "scp_ras_cri_intr" ||
                        interrupt_map[i].name == "mcp_ras_cri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_eri_intr": begin
                // Collect all interrupts that should be merged into iosub_ras_eri_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_eri_intr" ||
                        interrupt_map[i].name == "scp_ras_eri_intr" ||
                        interrupt_map[i].name == "mcp_ras_eri_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_ras_fhi_intr": begin
                // Collect all interrupts that should be merged into iosub_ras_fhi_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "smmu_fhi_intr" ||
                        interrupt_map[i].name == "scp_ras_fhi_intr" ||
                        interrupt_map[i].name == "mcp_ras_fhi_intr" ||
                        interrupt_map[i].name == "iodap_chk_err_etf0" ||
                        interrupt_map[i].name == "iodap_chk_err_etf1") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_0_intr": begin
                // Collect all interrupts that should be merged into iosub_abnormal_0_intr
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "iodap_etr_buf_intr" ||
                        interrupt_map[i].name == "iodap_catu_addrerr_intr") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            "iosub_abnormal_1_intr": begin
                // iosub_abnormal_1_intr is a reserved merge signal with no sources
                // This is intentionally empty as it's reserved for future use
                // No sources to collect for this merge signal
            end

            "merge_external_pll_intr": begin
                // Collect all external PLL interrupts that should be merged
                foreach (interrupt_map[i]) begin
                    if (interrupt_map[i].name == "accel_pll_lock_intr" ||
                        interrupt_map[i].name == "accel_pll_unlock_intr" ||
                        interrupt_map[i].name == "psub_pll_lock_intr" ||
                        interrupt_map[i].name == "psub_pll_unlock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_lock_intr" ||
                        interrupt_map[i].name == "pcie1_pll_unlock_intr" ||
                        interrupt_map[i].name == "d2d_pll_lock_intr" ||
                        interrupt_map[i].name == "d2d_pll_unlock_intr" ||
                        interrupt_map[i].name == "ddr0_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr1_pll_lock_intr" ||
                        interrupt_map[i].name == "ddr2_pll_lock_intr" ||
                        // CSUB PLL interrupts (array format)
                        interrupt_map[i].name.substr(0, 15) == "csub_pll_intr_lock") begin
                        sources.push_back(interrupt_map[i]);
                    end
                end
            end

            default: begin
                // Not a merge interrupt, return empty array
            end
        endcase

        return sources.size();
    endfunction

    // Function to check if an interrupt is a merge interrupt
    static function bit is_merge_interrupt(string interrupt_name);
        return (interrupt_name == "merge_pll_intr_lock" ||
                interrupt_name == "merge_pll_intr_unlock" ||
                interrupt_name == "merge_pll_intr_frechangedone" ||
                interrupt_name == "merge_pll_intr_frechange_tot_done" ||
                interrupt_name == "merge_pll_intr_intdocfrac_err" ||
                // New merge interrupts from CSV analysis
                interrupt_name == "iosub_normal_intr" ||
                interrupt_name == "iosub_slv_err_intr" ||
                interrupt_name == "iosub_ras_cri_intr" ||
                interrupt_name == "iosub_ras_eri_intr" ||
                interrupt_name == "iosub_ras_fhi_intr" ||
                interrupt_name == "iosub_abnormal_0_intr" ||
                interrupt_name == "iosub_abnormal_1_intr" ||
                interrupt_name == "merge_external_pll_intr");
    endfunction

    // Helper function to check if an interrupt exists in the interrupt map
    static function bit interrupt_exists(string interrupt_name);
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                return 1;
            end
        end
        return 0;
    endfunction

    // Function to get merge interrupt info by name
    static function interrupt_info_s get_merge_interrupt_info(string merge_interrupt_name);
        interrupt_info_s result;
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == merge_interrupt_name) begin
                return interrupt_map[i];
            end
        end
        // Return empty struct if not found
        result = '{default:0};
        return result;
    endfunction

    // Function to predict if an interrupt will be routed considering mask registers
    static function bit predict_interrupt_routing_with_mask(string interrupt_name, string destination);
        interrupt_info_s info;
        bit routing_enabled = 0;
        bit mask_enabled = 1;

        // First check if interrupt exists and has routing to destination
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                info = interrupt_map[i];
                break;
            end
        end

        // Check if routing is enabled for this destination
        case (destination.toupper())
            "AP": routing_enabled = info.to_ap;
            "SCP": routing_enabled = info.to_scp;
            "MCP": routing_enabled = info.to_mcp;
            "IMU": routing_enabled = info.to_imu;
            "IO": routing_enabled = info.to_io;
            "OTHER_DIE": routing_enabled = info.to_other_die;
            default: routing_enabled = 0;
        endcase

        // If routing is not enabled, interrupt won't be routed regardless of mask
        if (!routing_enabled) return 0;

        // Check if interrupt is masked (returns 1 if masked, 0 if enabled)
        mask_enabled = !int_register_model::is_interrupt_masked(interrupt_name, destination);

        // Interrupt will be routed if both routing is enabled AND mask is enabled
        return (routing_enabled && mask_enabled);
    endfunction

    // Function to get all expected destinations for an interrupt considering masks
    static function void get_expected_destinations_with_mask(string interrupt_name, ref string destinations[$]);
        string all_destinations[$] = {"AP", "SCP", "MCP", "IMU", "IO", "OTHER_DIE"};

        destinations.delete();

        foreach (all_destinations[i]) begin
            if (predict_interrupt_routing_with_mask(interrupt_name, all_destinations[i])) begin
                destinations.push_back(all_destinations[i]);
            end
        end
    endfunction

    // Function to check if any destination is expected for an interrupt
    static function bit has_any_expected_destination_with_mask(string interrupt_name);
        string destinations[$];
        get_expected_destinations_with_mask(interrupt_name, destinations);
        return (destinations.size() > 0);
    endfunction

    // Function to update status registers when interrupt occurs
    static function void update_interrupt_status(string interrupt_name, bit status_value);
        // Update the register model status
        int_register_model::update_status_register(interrupt_name, status_value);

        // Log the status update
        `uvm_info("INT_ROUTING_MODEL", $sformatf("Updated status for interrupt '%s' to %b",
                  interrupt_name, status_value), UVM_HIGH)
    endfunction

    // Function to print routing prediction with mask consideration
    static function void print_routing_prediction_with_mask(string interrupt_name);
        string destinations[$];
        interrupt_info_s info;

        // Get interrupt info
        foreach (interrupt_map[i]) begin
            if (interrupt_map[i].name == interrupt_name) begin
                info = interrupt_map[i];
                break;
            end
        end

        `uvm_info("INT_ROUTING_MODEL", $sformatf("=== Routing Prediction for '%s' ===", interrupt_name), UVM_MEDIUM)
        `uvm_info("INT_ROUTING_MODEL", $sformatf("Base routing: AP=%b, SCP=%b, MCP=%b, IMU=%b, IO=%b, OTHER_DIE=%b",
                  info.to_ap, info.to_scp, info.to_mcp, info.to_imu, info.to_io, info.to_other_die), UVM_MEDIUM)

        // Check each destination with mask consideration
        string all_destinations[$] = {"AP", "SCP", "MCP", "IMU", "IO", "OTHER_DIE"};
        foreach (all_destinations[i]) begin
            bit routing_enabled = predict_interrupt_routing_with_mask(interrupt_name, all_destinations[i]);
            bit mask_status = !int_register_model::is_interrupt_masked(interrupt_name, all_destinations[i]);
            `uvm_info("INT_ROUTING_MODEL", $sformatf("  %s: routing=%b, mask_enabled=%b, final=%b",
                      all_destinations[i],
                      (all_destinations[i] == "AP") ? info.to_ap :
                      (all_destinations[i] == "SCP") ? info.to_scp :
                      (all_destinations[i] == "MCP") ? info.to_mcp :
                      (all_destinations[i] == "IMU") ? info.to_imu :
                      (all_destinations[i] == "IO") ? info.to_io : info.to_other_die,
                      mask_status, routing_enabled), UVM_MEDIUM)
        end

        get_expected_destinations_with_mask(interrupt_name, destinations);
        if (destinations.size() > 0) begin
            `uvm_info("INT_ROUTING_MODEL", $sformatf("Expected destinations: %p", destinations), UVM_MEDIUM)
        end else begin
            `uvm_info("INT_ROUTING_MODEL", "No expected destinations (all masked or no routing)", UVM_MEDIUM)
        end
        `uvm_info("INT_ROUTING_MODEL", "=== End Routing Prediction ===", UVM_MEDIUM)
    endfunction

endclass

`endif // INT_ROUTING_MODEL_SV
